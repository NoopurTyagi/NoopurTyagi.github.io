<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Model Indoor Navigation</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
    #waypoints, #selected-waypoints, #path-waypoints {
      position: fixed;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
    }
    #waypoints { top: 0; right: 0; }
    #selected-waypoints { bottom: 0; left: 0; }
    #path-waypoints { bottom: 0; right: 0; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
</head>
<body>
  <h1>3D Demogorgon Model</h1>
  <div id="waypoints">
    <h2>Waypoints</h2>
    <ul id="waypoint-list"></ul>
  </div>
  <div id="selected-waypoints">
    <h2>Selected Waypoints</h2>
    <p>Start Waypoint: <span id="start-waypoint">None</span></p>
    <p>End Waypoint: <span id="end-waypoint">None</span></p>
  </div>
  <div id="path-waypoints">
    <h2>Waypoints Along the Path</h2>
    <ul id="path-waypoint-list"></ul>
    <button id="next-waypoint-btn" onclick="showNextWaypoint()">Next Waypoint</button>
    <p id="current-waypoint">Current Waypoint: None</p>
    <p id="reached-message" style="display: none;">You have reached the destination!</p>
  </div>
  <button onclick="navigate()">Navigate</button>

  <script>
    const waypoints = [
      { id: 1, name: "Entrance", x: -8, y: 0, z: -3, connected: [2] },
      { id: 2, name: "Corridor Intersection", x: -6, y: 0, z: -3, connected: [1, 3, 4, 5, 6, 7, 8] },
      { id: 3, name: "Faculty Room 03", x: -6, y: 0, z: -10, connected: [2] },
      { id: 4, name: "Faculty Room 004", x: -2, y: 0, z: 2, connected: [2] },
      { id: 5, name: "International Office", x: -6, y: 0, z: 2, connected: [2] },
      { id: 6, name: "Restroom 1", x: -4, y: 0, z: -10, connected: [2] },
      { id: 7, name: "Restroom 2", x: -2, y: 0, z: -10, connected: [2] },
      { id: 8, name: "Pantry", x: -1, y: 0, z: -7, connected: [2] },
      { id: 9, name: "Ground Floor Stairs", x: -1, y: 2, z: -5, connected: [2, 10] },
      { id: 10, name: "Ground Floor Stairs End", x: 0, y: 4, z: -6, connected: [9, 11] },
      { id: 11, name: "First Floor Stairs", x: 0, y: 4, z: -4, connected: [10, 12] },
      { id: 12, name: "Corridor", x: -5, y: 3.5, z: -4, connected: [11, 13] },
      { id: 13, name: "First Floor Corridor Intersection", x: -6, y: 3.5, z: 3, connected: [12, 14] },
      { id: 14, name: "LH2", x: -1, y: 3.5, z: -1, connected: [13] },
      { id: 15, name: "LH1", x: -1, y: 3.5, z: -1, connected: [14] }
    ];

    waypoints.forEach(waypoint => {
      waypoint.connected.forEach(conn => {
        const neighbor = waypoints.find(w => w.id === conn);
        if (neighbor && !neighbor.connected.includes(waypoint.id)) {
          neighbor.connected.push(waypoint.id);
        }
      });
    });

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1, 10);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.screenSpacePanning = false;
    controls.maxPolarAngle = Math.PI / 2;

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 10, 7.5).normalize();
    scene.add(directionalLight);

    let waypointMap = {};
    let startWaypoint = null;
    let endWaypoint = null;
    let line = null;
    let animatedObject = null;
    let animationPath = [];
    let animationIndex = 0;

    const loader = new THREE.GLTFLoader();
    loader.load('https://NoopurTyagi.github.io/mymodel4.gltf', function (gltf) {
      const model = gltf.scene;
      model.scale.set(1, 1, 1);
      scene.add(model);
      animate();
    }, undefined, function (error) {
      console.error(error);
    });

    const geometry = new THREE.SphereGeometry(0.1, 32, 32);
    const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });

    function createWaypointMarker(waypoint) {
      const sphere = new THREE.Mesh(geometry, material);
      sphere.position.set(waypoint.x, waypoint.y, waypoint.z);
      sphere.userData = waypoint;
      scene.add(sphere);
      waypointMap[waypoint.id] = sphere;
    }

    waypoints.forEach(createWaypointMarker);

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    function showNextWaypoint() {
      if (animationIndex < animationPath.length) {
        const nextWaypoint = animationPath[animationIndex];
        document.getElementById('current-waypoint').textContent = `Current Waypoint: ${nextWaypoint.name}`;
        animationIndex++;
        if (animationIndex === animationPath.length) {
          document.getElementById('reached-message').style.display = 'block';
        }
      }
    }

    function resetNavigation() {
      if (line) {
        scene.remove(line);
        line.geometry.dispose();
        line.material.dispose();
        line = null;
      }
      animationPath = [];
      animationIndex = 0;
      document.getElementById('path-waypoint-list').innerHTML = '';
      document.getElementById('current-waypoint').textContent = 'Current Waypoint: None';
      document.getElementById('reached-message').style.display = 'none';
    }

    function navigate() {
      if (startWaypoint && endWaypoint) {
        resetNavigation();
        const path = findPath(startWaypoint, endWaypoint);
        if (path) {
          animationPath = path;
          path.forEach(waypoint => {
            const li = document.createElement('li');
            li.textContent = waypoint.name;
            document.getElementById('path-waypoint-list').appendChild(li);
          });
          const pathPoints = path.map(waypoint => new THREE.Vector3(waypoint.x, waypoint.y, waypoint.z));
          const lineGeometry = new THREE.BufferGeometry().setFromPoints(pathPoints);
          const lineMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
          line = new THREE.Line(lineGeometry, lineMaterial);
          scene.add(line);
          document.getElementById('next-waypoint-btn').style.display = 'block';
        } else {
          alert('No path found!');
        }
      } else {
        alert('Please select both start and end waypoints.');
      }
    }

    function findPath(start, end) {
      const queue = [start];
      const cameFrom = {};
      cameFrom[start.id] = null;

      while (queue.length > 0) {
        const current = queue.shift();
        if (current === end) {
          const path = [];
          let temp = current;
          while (temp) {
            path.unshift(temp);
            temp = cameFrom[temp.id];
          }
          return path;
        }

        current.connected.forEach(connId => {
          const neighbor = waypoints.find(w => w.id === connId);
          if (!cameFrom[neighbor.id]) {
            queue.push(neighbor);
            cameFrom[neighbor.id] = current;
          }
        });
      }
      return null;
    }

    document.getElementById('waypoint-list').addEventListener('click', event => {
      const waypoint = waypoints.find(w => w.name === event.target.textContent);
      if (waypoint) {
        if (!startWaypoint) {
          startWaypoint = waypoint;
          document.getElementById('start-waypoint').textContent = waypoint.name;
        } else if (!endWaypoint) {
          endWaypoint = waypoint;
          document.getElementById('end-waypoint').textContent = waypoint.name;
        }
      }
    });

    waypoints.forEach(waypoint => {
      const li = document.createElement('li');
      li.textContent = waypoint.name;
      document.getElementById('waypoint-list').appendChild(li);
    });
  </script>
</body>
</html>
