<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Navigation System</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
        }
        #path-waypoint-list {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h2>Add Waypoint</h2>
        <label for="waypoint-name">Name:</label>
        <input type="text" id="waypoint-name" />
        <label for="waypoint-x">X:</label>
        <input type="number" id="waypoint-x" />
        <label for="waypoint-y">Y:</label>
        <input type="number" id="waypoint-y" />
        <label for="waypoint-z">Z:</label>
        <input type="number" id="waypoint-z" />
        <button onclick="addWaypoint()">Add Waypoint</button>
    </div>
    <ul id="path-waypoint-list"></ul>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        let scene, camera, renderer, controls, line;
        let waypoints = [];
        let waypointMap = {};
        let markers = [];
        let animationPath = [];
        let animationIndex = 0;
        let gltfModel;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(10, 10, 10).normalize();
            scene.add(light);

            camera.position.set(0, 5, 10);

            // Load glTF model
            const loader = new THREE.GLTFLoader();
            loader.load('https://NoopurTyagi.github.io/mymodel4.gltf', function (gltf) {
                gltfModel = gltf.scene;
                scene.add(gltfModel);
            }, undefined, function (error) {
                console.error(error);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function addWaypoint() {
            const name = document.getElementById('waypoint-name').value;
            const x = parseFloat(document.getElementById('waypoint-x').value);
            const y = parseFloat(document.getElementById('waypoint-y').value);
            const z = parseFloat(document.getElementById('waypoint-z').value);
            const newId = waypoints.length ? waypoints[waypoints.length - 1].id + 1 : 1;

            const newWaypoint = { id: newId, name, x, y, z, connected: [] };
            waypoints.push(newWaypoint);
            waypointMap[newId] = newWaypoint;

            const markerGeometry = new THREE.SphereGeometry(0.1, 32, 32);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.set(x, y, z);
            scene.add(marker);
            markers.push(marker);

            console.log(`Waypoint added: ${name} at (${x}, ${y}, ${z})`);
        }

        function checkPathObstruction(path) {
            const obstacles = [
                { x: -5, y: 0, z: -3 },
                { x: 0, y: 0, z: -5 }
            ];

            for (const waypoint of path) {
                for (const obstacle of obstacles) {
                    if (waypoint.x === obstacle.x && waypoint.y === obstacle.y && waypoint.z === obstacle.z) {
                        return true;
                    }
                }
            }
            return false;
        }

        function findPathAndDraw(start, end) {
            if (line) {
                scene.remove(line);
            }

            const path = findPath(start, end);
            if (path.length === 0) {
                alert("No path found!");
                return;
            }

            if (checkPathObstruction(path)) {
                alert("Path is obstructed!");
                return;
            }

            const points = path.map(waypoint => new THREE.Vector3(waypoint.x, waypoint.y, waypoint.z));
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
            line = new THREE.Line(geometry, material);
            scene.add(line);

            const pathWaypointList = document.getElementById('path-waypoint-list');
            pathWaypointList.innerHTML = '';
            path.forEach((waypoint, index) => {
                const listItem = document.createElement('li');
                listItem.textContent = `${index + 1}. ${waypoint.name}`;
                pathWaypointList.appendChild(listItem);
            });

            animationPath = path;
            animationIndex = 0;

            console.log('Path found and drawn');
        }

        function findPath(start, end) {
            const openSet = new Set([start.id]);
            const cameFrom = {};
            const gScore = { [start.id]: 0 };
            const fScore = { [start.id]: heuristic(start, end) };

            while (openSet.size > 0) {
                let currentId = null;
                openSet.forEach(id => {
                    if (!currentId || fScore[id] < fScore[currentId]) {
                        currentId = id;
                    }
                });

                if (currentId === end.id) {
                    return reconstructPath(cameFrom, currentId);
                }

                openSet.delete(currentId);
                for (const neighbor of waypointMap[currentId].connected) {
                    const tentativeGScore = gScore[currentId] + distance(waypointMap[currentId], waypointMap[neighbor]);
                    if (tentativeGScore < (gScore[neighbor] || Infinity)) {
                        cameFrom[neighbor] = currentId;
                        gScore[neighbor] = tentativeGScore;
                        fScore[neighbor] = gScore[neighbor] + heuristic(waypointMap[neighbor], end);
                        openSet.add(neighbor);
                    }
                }
            }

            return [];
        }

        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y) + Math.abs(a.z - b.z);
        }

        function distance(a, b) {
            return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2 + (a.z - b.z) ** 2);
        }

        function reconstructPath(cameFrom, currentId) {
            const path = [waypointMap[currentId]];
            while (cameFrom[currentId]) {
                currentId = cameFrom[currentId];
                path.unshift(waypointMap[currentId]);
            }
            return path;
        }

        function updateModelWithRealTimeData(data) {
            data.waypoints.forEach(rtWaypoint => {
                const existingWaypoint = waypointMap[rtWaypoint.id];
                if (existingWaypoint) {
                    existingWaypoint.x = rtWaypoint.x;
                    existingWaypoint.y = rtWaypoint.y;
                    existingWaypoint.z = rtWaypoint.z;
                } else {
                    const newWaypoint = {
                        id: rtWaypoint.id,
                        name: rtWaypoint.name,
                        x: rtWaypoint.x,
                        y: rtWaypoint.y,
                        z: rtWaypoint.z,
                        connected: rtWaypoint.connected
                    };
                    waypoints.push(newWaypoint);
                    waypointMap[rtWaypoint.id] = newWaypoint;
                }
            });
        }

        const realTimeData = {
            waypoints: [
               { id: 1, name: "Entrance", x: -8, y: 0, z: -3, connected: [2] },
      { id: 2, name: "Corridor Intersection", x: -6, y: 0, z: -3, connected: [1, 3, 4, 5, 6, 7, 8] },
      { id: 3, name: "Faculty Room 03", x: -6, y: 0, z: -10, connected: [2] },
      { id: 4, name: "Faculty Room 004", x: -2, y: 0, z: 2, connected: [2] },
      { id: 5, name: "Faculty Room 005", x: -6, y: 0, z: 2, connected: [2] },
      { id: 6, name: "Restroom 1", x: -4, y: 0, z: -10, connected: [2] },
      { id: 7, name: "Restroom 2", x: -2, y: 0, z: -10, connected: [2] },
      { id: 8, name: "Pantry", x: -1, y: 0, z: -7, connected: [2] },
      { id: 9, name: "Ground Floor Stairs", x: -1, y: 2, z: -5, connected: [2, 10] },
      { id: 10, name: "Ground Floor Stairs End", x: 0, y: 4, z: -6, connected: [9, 11] },
      { id: 11, name: "First Floor Stairs", x: 0, y: 4, z: -4, connected: [10, 12] },
      { id: 12, name: "Corridor", x: -5, y: 3.5, z: -4, connected: [11, 13] },
      { id: 13, name: "First Floor Corridor Intersection", x: -6, y: 3.5, z: 3, connected: [12, 14] },
      { id: 14, name: "LH1", x: -6, y: 3.5, z: 5, connected: [13,15] },
      { id: 15, name: "LH2", x: -6, y: 3.5, z: 8, connected: [13] },
      { id: 16, name: "LH3", x: -6, y: 3.5, z: -10, connected: [12] },
      { id: 17, name: "LH4", x: -6, y: 3.5, z: -12, connected: [12,16] },
      { id: 18, name: "second Floor Stairs", x: 0, y: 5, z: -4, connected: [11,19] },
      { id: 19, name: "second Floor Stairs End", x: 0, y: 7, z: -4, connected: [18,20] },
      { id: 20, name: "third Floor corridor", x: -5, y: 7, z: -3, connected: [19,21] },
      { id: 21, name: "third Floor corridor intersection ", x: -5, y: 7, z: -2, connected: [20,21] },
      { id: 22, name: "LH5", x: -5, y: 7, z: 5, connected: [21,23] },
      { id: 23, name: "LH6", x: -5, y: 7, z: 8, connected: [22] },
      { id: 24, name: "Restroom3", x: -5, y: 7, z: -5, connected: [20] },
      
    ];
        updateModelWithRealTimeData(realTimeData);
    </script>
</body>
</html>

